<!doctype html>
<html lang="vi" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProEditor ‚Äî AI Powered</title>

    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = { darkMode: "class" };
    </script>

    <!-- React UMD -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- TinyMCE CDN (no API key needed for basic cloud CDN usage; if blocked, replace with your self-host) -->
    <script src="https://cdn.tiny.cloud/1/no-api-key/tinymce/6/tinymce.min.js" referrerpolicy="origin"></script>

    <!-- Mammoth (docx -> html) -->
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>

    <style>
      /* Scrollbar (nice) */
      ::-webkit-scrollbar { width: 10px; height: 10px; }
      ::-webkit-scrollbar-thumb { background: rgba(120,120,120,.35); border-radius: 999px; }
      ::-webkit-scrollbar-thumb:hover { background: rgba(120,120,120,.5); }

      /* Loader overlay */
      .editor-overlay {
        position: absolute; inset: 0;
        display: flex; align-items: center; justify-content: center;
        background: rgba(255,255,255,.75);
        backdrop-filter: blur(2px);
      }
      html.dark .editor-overlay { background: rgba(0,0,0,.55); }

      /* Highlight chunk ƒëang x·ª≠ l√Ω */
      .processing-chunk {
        outline: 2px dashed rgba(59, 130, 246, .75);
        outline-offset: 4px;
        border-left: 6px solid rgba(59, 130, 246, .85);
        padding-left: 10px !important;
        border-radius: 6px;
        background: rgba(59,130,246,.06);
      }

      /* Fake A4 paper */
      .paper {
        width: min(23cm, 100%);
        min-height: 29.7cm;
        background: white;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0,0,0,.10);
        margin: 0 auto;
        padding: 18mm 16mm;
      }
      html.dark .paper {
        background: #0b0f17;
        box-shadow: 0 10px 30px rgba(0,0,0,.45);
      }

      /* TinyMCE container feel */
      .tox.tox-tinymce { border-radius: 14px !important; overflow: hidden; }
      html.dark .tox.tox-tinymce { border: 1px solid rgba(255,255,255,.08) !important; }
    </style>
  </head>

  <body class="h-full bg-slate-50 text-slate-900 dark:bg-[#070A12] dark:text-slate-100">
    <div id="root" class="h-full"></div>

    <script>
      const { useEffect, useMemo, useRef, useState } = React;

      // ====== CONFIG ======
      const DEFAULT_WEBHOOK =
        "https://rasp.nthang91.io.vn/webhook/8f519f68-9c8b-49cf-a8de-76c50f5a373b";

      const DEMO_HTML = `
        <h1>ProEditor ‚Äî Demo</h1>
        <p>ƒê√¢y l√† n·ªôi dung demo ƒë·ªÉ test editor. B·∫°n c√≥ th·ªÉ nh·∫≠p Word (.docx), s·ª≠a n·ªôi dung, r·ªìi b·∫•m <b>T·ª± ƒë·ªông s·ª≠a</b> ƒë·ªÉ g·ª≠i t·ª´ng ƒëo·∫°n qua webhook AI.</p>
        <h2>Checklist</h2>
        <ul>
          <li>Import .docx (Mammoth)</li>
          <li>Editor WYSIWYG (TinyMCE)</li>
          <li>Auto Fix chia chunk theo block node</li>
          <li>Restore ·∫£nh b·∫±ng placeholder</li>
        </ul>
        <h2>B·∫£ng m·∫´u</h2>
        <table style="border-collapse: collapse; width: 100%;" border="1">
          <tr><th>H·∫°ng m·ª•c</th><th>Tr·∫°ng th√°i</th></tr>
          <tr><td>Ch√≠nh t·∫£</td><td>Ch·ªù AI</td></tr>
          <tr><td>ƒê·ªãnh d·∫°ng</td><td>Ch·ªù AI</td></tr>
        </table>
        <p><i>M·∫πo:</i> n·∫øu ch·∫°y GitHub Pages m√† Auto Fix l·ªói, kh·∫£ nƒÉng cao l√† do <b>CORS</b> ·ªü webhook.</p>
      `;

      // ====== HELPERS ======
      function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

      function escapeHtml(str) {
        return String(str)
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function estimateWordsFromText(text) {
        const t = (text || "").trim();
        if (!t) return 0;
        return t.split(/\s+/).filter(Boolean).length;
      }

      function pickHtmlFromResponse(json) {
        if (!json) return "";
        if (typeof json === "string") return json;
        return json.html || json.output || json.text || "";
      }

      function wrapTopLevelChildren(children) {
        const wrapper = document.createElement("div");
        children.forEach(n => wrapper.appendChild(n.cloneNode(true)));
        return wrapper;
      }

      function replaceImagesWithPlaceholders(rootEl) {
        const imageMap = new Map();
        const imgs = rootEl.querySelectorAll("img");
        imgs.forEach((img, idx) => {
          const id = `IMG_${Date.now()}_${Math.random().toString(16).slice(2)}_${idx}`;
          imageMap.set(id, img.outerHTML);
          const placeholder = document.createTextNode(id);
          img.replaceWith(placeholder);
        });
        return imageMap;
      }

      function restoreImagesFromPlaceholders(html, imageMap) {
        let out = html;
        for (const [id, imgHtml] of imageMap.entries()) {
          // replace all occurrences
          out = out.split(id).join(imgHtml);
        }
        return out;
      }

      // ====== MODAL ======
      function Modal({ open, title, children, onClose }) {
        if (!open) return null;
        return React.createElement(
          "div",
          { className: "fixed inset-0 z-50 flex items-center justify-center p-4" },
          React.createElement("div", {
            className: "absolute inset-0 bg-black/50",
            onClick: onClose
          }),
          React.createElement(
            "div",
            { className: "relative z-10 w-full max-w-4xl rounded-2xl bg-white p-4 shadow-2xl dark:bg-[#0B1020] border border-black/5 dark:border-white/10" },
            React.createElement("div", { className: "flex items-center justify-between gap-3" },
              React.createElement("div", { className: "text-lg font-semibold" }, title),
              React.createElement("button", {
                className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                onClick: onClose
              }, "ƒê√≥ng")
            ),
            React.createElement("div", { className: "mt-3" }, children)
          )
        );
      }

      // ====== APP ======
      function App() {
        const editorRef = useRef(null);
        const [isEditorReady, setEditorReady] = useState(false);

        const [dark, setDark] = useState(false);
        const [content, setContent] = useState(DEMO_HTML);

        const [wordCount, setWordCount] = useState(0);
        const [isFixing, setFixing] = useState(false);
        const [progress, setProgress] = useState({ current: 0, total: 0 });

        const [showHtml, setShowHtml] = useState(false);
        const [webhookUrl, setWebhookUrl] = useState(DEFAULT_WEBHOOK);

        const fileInputRef = useRef(null);

        // Apply dark mode class
        useEffect(() => {
          document.documentElement.classList.toggle("dark", !!dark);
        }, [dark]);

        // Init / Re-init TinyMCE when dark changes
        useEffect(() => {
          let cancelled = false;

          async function init() {
            setEditorReady(false);

            // Destroy existing editor if any
            if (tinymce?.get("editor-textarea")) {
              try { tinymce.get("editor-textarea").remove(); } catch (e) {}
            }

            // Small delay to let DOM settle
            await sleep(10);
            if (cancelled) return;

            tinymce.init({
              selector: "#editor-textarea",
              height: 1100,
              menubar: true,
              branding: false,
              plugins: "lists link image table media wordcount code autoresize",
              toolbar:
                "undo redo | blocks | bold italic underline | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | table link image media | removeformat | code",
              skin: dark ? "oxide-dark" : "oxide",
              content_css: dark ? "dark" : "default",
              content_style: dark
                ? "body{background:#0b0f17;color:#e5e7eb;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;line-height:1.7;} h1,h2,h3{color:#fff}"
                : "body{background:#fff;color:#0f172a;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;line-height:1.7;}",
              setup: (editor) => {
                editorRef.current = editor;

                editor.on("init", () => {
                  if (cancelled) return;
                  editor.setContent(content || "");
                  setEditorReady(true);

                  // initial wordcount
                  try {
                    const wc = editor.plugins.wordcount?.getCount?.() ?? estimateWordsFromText(editor.getContent({ format: "text" }));
                    setWordCount(wc);
                  } catch (e) {}
                });

                const sync = () => {
                  try {
                    const html = editor.getContent();
                    setContent(html);

                    const wc = editor.plugins.wordcount?.getCount?.() ?? estimateWordsFromText(editor.getContent({ format: "text" }));
                    setWordCount(wc);
                  } catch (e) {}
                };

                editor.on("Change KeyUp SetContent Undo Redo", sync);
              }
            });
          }

          init();
          return () => { cancelled = true; };
        }, [dark]);

        function handleImportWordClick() {
          fileInputRef.current?.click?.();
        }

        async function handleDocxPicked(ev) {
          const file = ev.target.files?.[0];
          ev.target.value = ""; // allow re-pick same file
          if (!file) return;

          try {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.convertToHtml({ arrayBuffer });
            const html = result?.value || "";
            const ed = editorRef.current;
            if (ed) ed.setContent(html);
            setContent(html);
            alert("‚úÖ Import Word th√†nh c√¥ng!");
          } catch (err) {
            console.error(err);
            alert("‚ùå Import th·∫•t b·∫°i. Xem console ƒë·ªÉ bi·∫øt l·ªói.");
          }
        }

        async function handleCopyHtml() {
          try {
            await navigator.clipboard.writeText(content || "");
            alert("‚úÖ ƒê√£ copy HTML!");
          } catch (e) {
            alert("‚ùå Kh√¥ng copy ƒë∆∞·ª£c (tr√¨nh duy·ªát ch·∫∑n clipboard).");
          }
        }

        async function testWebhook() {
          try {
            const res = await fetch(webhookUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                ping: true,
                source: "ProEditor",
                time: new Date().toISOString()
              })
            });

            if (!res.ok) {
              alert(`‚ùå Webhook tr·∫£ v·ªÅ HTTP ${res.status}. (CORS c≈©ng c√≥ th·ªÉ l√† nguy√™n nh√¢n)`);
              return;
            }

            // best effort parse
            let json = null;
            try { json = await res.json(); } catch (e) {}
            alert("‚úÖ Webhook OK! " + (json ? "(C√≥ JSON response)" : "(Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c JSON nh∆∞ng status OK)"));
          } catch (err) {
            console.error(err);
            alert("‚ùå Kh√¥ng g·ªçi ƒë∆∞·ª£c webhook. 90% l√† CORS ho·∫∑c m·∫°ng.");
          }
        }

        async function autoFix() {
          const ed = editorRef.current;
          if (!ed) return;

          const CHUNK_WORD_LIMIT = 400;
          const body = ed.getBody();
          if (!body) return;

          const topNodes = Array.from(body.children);
          if (topNodes.length === 0) {
            alert("Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ s·ª≠a.");
            return;
          }

          // Build chunks by word limit
          const chunks = [];
          let current = [];
          let currentWords = 0;

          for (const node of topNodes) {
            const w = estimateWordsFromText(node.innerText);
            if (current.length > 0 && (currentWords + w) > CHUNK_WORD_LIMIT) {
              chunks.push(current);
              current = [];
              currentWords = 0;
            }
            current.push(node);
            currentWords += w;
          }
          if (current.length) chunks.push(current);

          setFixing(true);
          setProgress({ current: 0, total: chunks.length });

          let okCount = 0;

          for (let i = 0; i < chunks.length; i++) {
            setProgress({ current: i + 1, total: chunks.length });

            const chunkNodes = chunks[i];
            // Highlight
            chunkNodes.forEach(n => n.classList.add("processing-chunk"));

            try {
              // Clone chunk nodes into a wrapper
              const wrapper = document.createElement("div");
              chunkNodes.forEach(n => wrapper.appendChild(n.cloneNode(true)));

              // Replace images with placeholders to protect <img>
              const imageMap = replaceImagesWithPlaceholders(wrapper);

              const htmlToSend = wrapper.innerHTML;

              const res = await fetch(webhookUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  html: htmlToSend,
                  chunkIndex: i + 1,
                  totalChunks: chunks.length,
                  source: "ProEditor"
                })
              });

              if (!res.ok) throw new Error("HTTP " + res.status);

              let json;
              try { json = await res.json(); }
              catch (e) {
                // If webhook returns text
                const txt = await res.text();
                json = { text: txt };
              }

              let newHtml = pickHtmlFromResponse(json);

              // If webhook doesn't return html -> skip replace
              if (!newHtml || !String(newHtml).trim()) {
                chunkNodes.forEach(n => n.classList.remove("processing-chunk"));
                continue;
              }

              // Restore images
              newHtml = restoreImagesFromPlaceholders(String(newHtml), imageMap);

              // Parse returned HTML and replace old chunk nodes
              const temp = document.createElement("div");
              temp.innerHTML = newHtml;

              const newNodes = Array.from(temp.children);
              const firstOld = chunkNodes[0];

              // Insert new nodes before old chunk
              for (const nn of newNodes) {
                body.insertBefore(nn, firstOld);
              }

              // Remove old nodes
              chunkNodes.forEach(n => n.remove());

              okCount++;
            } catch (err) {
              console.error(err);
              // Remove highlight
              chunkNodes.forEach(n => n.classList.remove("processing-chunk"));

              const cont = confirm(
                "‚ùå L·ªói khi x·ª≠ l√Ω chunk " + (i + 1) +
                ".\nR·∫•t c√≥ th·ªÉ do CORS tr√™n GitHub Pages.\n\nB·∫°n c√≥ mu·ªën ti·∫øp t·ª•c c√°c chunk sau kh√¥ng?"
              );
              if (!cont) break;
            } finally {
              // Safety: remove highlight from remaining nodes still present
              Array.from(body.querySelectorAll(".processing-chunk"))
                .forEach(n => n.classList.remove("processing-chunk"));
            }
          }

          // Sync editor state
          try {
            ed.fire("Change");
          } catch (e) {}

          setFixing(false);
          setProgress({ current: 0, total: 0 });
          alert(`‚úÖ Auto Fix xong. S·ª≠a th√†nh c√¥ng: ${okCount}/${chunks.length} chunk.`);
        }

        const statusText = useMemo(() => {
          if (isFixing) return `ƒêang s·ª≠a: ${progress.current}/${progress.total}`;
          return `Words: ${wordCount}`;
        }, [isFixing, progress, wordCount]);

        return React.createElement(
          "div",
          { className: "h-full flex flex-col" },

          // ===== Header =====
          React.createElement(
            "header",
            { className: "sticky top-0 z-40 border-b border-black/5 dark:border-white/10 bg-white/70 dark:bg-[#070A12]/70 backdrop-blur" },
            React.createElement(
              "div",
              { className: "mx-auto max-w-[1400px] px-4 py-3 flex items-center gap-3" },

              // Logo + name
              React.createElement("div", { className: "flex items-center gap-3" },
                React.createElement("div", {
                  className: "h-10 w-10 rounded-2xl bg-gradient-to-br from-indigo-500 to-sky-500 shadow-md"
                }),
                React.createElement("div", null,
                  React.createElement("div", { className: "flex items-center gap-2" },
                    React.createElement("div", { className: "text-lg font-semibold leading-none" }, "ProEditor"),
                    React.createElement("span", { className: "text-xs px-2 py-1 rounded-full bg-indigo-600 text-white" }, "AI Powered")
                  ),
                  React.createElement("div", { className: "text-xs text-slate-500 dark:text-slate-400" }, statusText)
                )
              ),

              React.createElement("div", { className: "flex-1" }),

              // Webhook input
              React.createElement("div", { className: "hidden md:flex items-center gap-2 max-w-[560px] w-full" },
                React.createElement("span", { className: "text-xs text-slate-500 dark:text-slate-400 whitespace-nowrap" }, "Webhook"),
                React.createElement("input", {
                  className: "w-full rounded-xl px-3 py-2 text-sm bg-slate-100 dark:bg-white/10 border border-black/5 dark:border-white/10 focus:outline-none focus:ring-2 focus:ring-sky-500/50",
                  value: webhookUrl,
                  onChange: (e) => setWebhookUrl(e.target.value)
                })
              ),

              // Actions
              React.createElement("div", { className: "flex items-center gap-2" },
                React.createElement("button", {
                  className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                  onClick: () => setDark(v => !v),
                  title: "Dark mode"
                }, dark ? "‚òÄÔ∏è" : "üåô"),

                React.createElement("button", {
                  className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                  onClick: testWebhook,
                  title: "Test Webhook"
                }, "üì° Test"),

                React.createElement("button", {
                  className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                  onClick: handleImportWordClick
                }, "üìÑ Nh·∫≠p Word"),

                React.createElement("button", {
                  className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                  onClick: () => setShowHtml(true)
                }, "üßæ HTML"),

                React.createElement("button", {
                  className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                  onClick: () => alert("ƒê√£ l∆∞u n·ªôi dung! (demo)")
                }, "üíæ L∆∞u"),

                React.createElement("button", {
                  className: "rounded-xl px-4 py-2 text-sm font-semibold bg-gradient-to-r from-indigo-600 to-sky-500 text-white shadow-lg hover:opacity-95 disabled:opacity-50",
                  onClick: autoFix,
                  disabled: isFixing || !isEditorReady
                }, isFixing ? "ƒêang s·ª≠a..." : "‚ú® T·ª± ƒë·ªông s·ª≠a")
              )
            )
          ),

          // hidden file input
          React.createElement("input", {
            ref: fileInputRef,
            type: "file",
            accept: ".docx",
            className: "hidden",
            onChange: handleDocxPicked
          }),

          // ===== Main =====
          React.createElement(
            "main",
            { className: "flex-1 overflow-hidden" },
            React.createElement(
              "div",
              { className: "h-full mx-auto max-w-[1400px] px-4 py-4 grid grid-cols-12 gap-4" },

              // Sidebar
              React.createElement(
                "aside",
                { className: "col-span-12 lg:col-span-3 xl:col-span-2 overflow-hidden" },
                React.createElement(
                  "div",
                  { className: "h-full rounded-2xl border border-black/5 dark:border-white/10 bg-white/70 dark:bg-white/5 p-4 overflow-auto" },
                  React.createElement("div", { className: "font-semibold mb-2" }, "VƒÉn b·∫£n g·∫ßn ƒë√¢y"),
                  React.createElement("div", { className: "text-sm text-slate-600 dark:text-slate-300 space-y-2" },
                    React.createElement("div", { className: "p-3 rounded-xl bg-slate-100 dark:bg-white/10" }, "üìå Demo Document"),
                    React.createElement("div", { className: "p-3 rounded-xl bg-slate-100 dark:bg-white/10 opacity-70" }, "üìù Placeholder 1"),
                    React.createElement("div", { className: "p-3 rounded-xl bg-slate-100 dark:bg-white/10 opacity-70" }, "üìù Placeholder 2")
                  ),
                  React.createElement("div", { className: "mt-4 font-semibold mb-2" }, "M·∫πo"),
                  React.createElement("div", { className: "text-sm text-slate-600 dark:text-slate-300 leading-relaxed" },
                    React.createElement("ul", { className: "list-disc pl-5 space-y-1" },
                      React.createElement("li", null, "Auto Fix s·∫Ω chia theo block (p, h, ul, table...)"),
                      React.createElement("li", null, "M·ªói chunk ~400 t·ª´ ƒë·ªÉ webhook x·ª≠ l√Ω ·ªïn"),
                      React.createElement("li", null, "N·∫øu GitHub Pages l·ªói: ki·ªÉm tra CORS tr√™n webhook")
                    )
                  )
                )
              ),

              // Editor area
              React.createElement(
                "section",
                { className: "col-span-12 lg:col-span-9 xl:col-span-10 overflow-hidden" },
                React.createElement(
                  "div",
                  { className: "h-full rounded-2xl border border-black/5 dark:border-white/10 bg-white/70 dark:bg-white/5 overflow-auto p-4" },

                  React.createElement("div", { className: "paper relative" },
                    React.createElement("textarea", { id: "editor-textarea" }),

                    !isEditorReady && React.createElement(
                      "div",
                      { className: "editor-overlay rounded-2xl" },
                      React.createElement(
                        "div",
                        { className: "flex items-center gap-3 rounded-2xl px-4 py-3 bg-white shadow-lg dark:bg-[#0B1020] border border-black/5 dark:border-white/10" },
                        React.createElement("div", { className: "h-4 w-4 rounded-full animate-pulse bg-sky-500" }),
                        React.createElement("div", { className: "text-sm text-slate-700 dark:text-slate-200" }, "ƒêang kh·ªüi t·∫°o editor...")
                      )
                    )
                  )
                )
              )
            )
          ),

          // ===== HTML Modal =====
          React.createElement(
            Modal,
            { open: showHtml, title: "HTML hi·ªán t·∫°i", onClose: () => setShowHtml(false) },
            React.createElement("div", { className: "flex items-center justify-between gap-2 mb-2" },
              React.createElement("div", { className: "text-xs text-slate-500 dark:text-slate-400" },
                "Copy HTML ƒë·ªÉ ƒëem ƒëi debug / paste qua ch·ªó kh√°c."
              ),
              React.createElement("button", {
                className: "rounded-xl px-3 py-2 text-sm bg-slate-100 hover:bg-slate-200 dark:bg-white/10 dark:hover:bg-white/15",
                onClick: handleCopyHtml
              }, "Copy")
            ),
            React.createElement("textarea", {
              className: "w-full h-[55vh] rounded-2xl p-3 text-xs font-mono bg-slate-100 dark:bg-black/40 border border-black/5 dark:border-white/10 focus:outline-none",
              readOnly: true,
              value: content || ""
            })
          )
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));
    </script>
  </body>
</html>
